<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#111111" />
  <title>Habit Hourglass</title>

  <!-- PWAï¼ˆè‹¥é‚„æ²’åš manifest.json / service-worker.jsï¼Œä¹‹å¾Œå¯å†è£œï¼‰ -->
  <link rel="manifest" href="./manifest.json" />

  <!-- Tailwindï¼ˆCDNï¼‰ -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- React 18ï¼ˆUMDï¼‰ + Babel Standaloneï¼ˆè®“ç€è¦½å™¨èƒ½ç·¨è­¯ JSXï¼‰ -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-neutral-50 text-neutral-900">
  <div id="root"></div>

  <!-- Service Worker è¨»å†Šï¼ˆè‹¥ç„¡æª”æ¡ˆæœƒè‡ªå‹•å¤±æ•—ç„¡å®³ï¼‰ -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js').catch(() => {});
      });
    }
  </script>

  <!-- App ç¨‹å¼ç¢¼ -->
  <script type="text/babel" data-presets="env,react">
    const { useEffect, useMemo, useState } = React;

    // ===== Utilities =====
    const todayKey = () => new Date().toISOString().slice(0, 10);
    const uid = () => Math.random().toString(36).slice(2, 9);

    const LS_KEY = "habit_bar_chart_v1";
    const loadState = () => {
      try { const raw = localStorage.getItem(LS_KEY); return raw ? JSON.parse(raw) : null; }
      catch { return null; }
    };
    const saveState = (state) => localStorage.setItem(LS_KEY, JSON.stringify(state));

    // ä½é£½å’Œã€æŸ”å’Œè‰²ç³»
    const PALETTE = ["#6b7280","#9aa5b1","#8fa3a3","#a3a0b5","#b0a68a","#b28d8d","#8ea0b0","#9aa79a"];

    // ===== Iconsï¼ˆé»‘ç™½ç·šæ¢ï¼Œå…§åµŒ SVGï¼‰ =====
    const IconRotateCcw = ({ size=16, strokeWidth=2 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none"
           stroke="currentColor" strokeWidth={strokeWidth} strokeLinecap="round" strokeLinejoin="round">
        <polyline points="1 4 1 10 7 10"></polyline>
        <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path>
      </svg>
    );
    const IconTrash = ({ size=16, strokeWidth=2 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none"
           stroke="currentColor" strokeWidth={strokeWidth} strokeLinecap="round" strokeLinejoin="round">
        <polyline points="3 6 5 6 21 6"></polyline>
        <path d="M19 6l-1 14a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2L5 6"></path>
        <path d="M10 11v6"></path>
        <path d="M14 11v6"></path>
        <path d="M9 6V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"></path>
      </svg>
    );

    // ===== SegmentedBarï¼šæ¯ +1 ç­‰å¯¬ä¸€æ®µï¼Œå³ç«¯æ°¸é æ˜¯æœ€æ–° =====
    function SegmentedBar({ blocks, target }) {
      const unitPct = 100 / Math.max(1, target);
      const slice = blocks.slice(-target); // åªé¡¯ç¤ºæœ€è¿‘ target å€‹
      return (
        <div className="w-full h-3 bg-neutral-200 rounded-full overflow-hidden relative">
          {slice.map((color, i) => (
            <div key={i}
                 className="absolute inset-y-0"
                 style={{ left: (i * unitPct) + "%", width: unitPct + "%", background: color }} />
          ))}
        </div>
      );
    }

    // ===== Inline Editable =====
    function EditableText({ value, onChange, placeholder = "" }) {
      const [editing, setEditing] = useState(false);
      const [val, setVal] = useState(value);
      useEffect(() => setVal(value), [value]);
      return editing ? (
        <input autoFocus
               className="border-b border-neutral-400 bg-transparent focus:outline-none text-sm"
               value={val}
               placeholder={placeholder}
               onChange={(e)=>setVal(e.target.value)}
               onBlur={()=>{ setEditing(false); onChange(val.trim() || value); }}
               onKeyDown={(e)=> e.key==="Enter" && (setEditing(false), onChange(val.trim() || value)) } />
      ) : (
        <button className="border-b border-neutral-300 hover:border-neutral-900 text-sm"
                onClick={()=>setEditing(true)}>
          {value || placeholder}
        </button>
      );
    }

    function EditableNumber({ value, onChange, min=1 }) {
      const [editing,setEditing]=useState(false);
      const [val,setVal]=useState(String(value ?? ""));
      useEffect(()=>setVal(String(value ?? "")),[value]);
      const commit=()=>{ const n = Math.max(min, Number(val || min)); setEditing(false); onChange(n); };
      return editing ? (
        <input autoFocus inputMode="numeric" pattern="[0-9]*"
               className="w-16 border-b border-neutral-400 text-right bg-transparent focus:outline-none"
               value={val}
               onChange={(e)=>setVal(e.target.value.replace(/[^0-9]/g,""))}
               onBlur={commit}
               onKeyDown={(e)=> e.key==="Enter" && commit() } />
      ) : (
        <button className="border-b border-neutral-300 hover:border-neutral-900 font-mono"
                onClick={()=>setEditing(true)}>
          {value}
        </button>
      );
    }

    // ===== New Habit =====
    function NewHabit({ onAdd }) {
      const [val,setVal]=useState("");
      return (
        <div className="flex gap-2">
          <input value={val} onChange={(e)=>setVal(e.target.value)} className="flex-1 rounded-xl border p-2" />
          <button className="px-3 py-2 rounded-xl bg-black text-white"
                  aria-label="æ–°å¢"
                  onClick={()=>{ onAdd(val); setVal(""); }}>ï¼‹</button>
        </div>
      );
    }

    // ===== Habit Card =====
    function HabitCard({ habit, onToggleToday, onRemove, onRename, periodStart, periodEnd, todayDoneCount }) {
      const doneToday = todayDoneCount>0; // ç”± events è¨ˆç®—
      const inRangeCount = habit.countInRange; // å‚³å…¥è¨ˆç®—å€¼
      return (
        <div className="rounded-2xl bg-white shadow p-4 flex flex-col gap-3">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              <span className="inline-block w-2.5 h-2.5 rounded-full" style={{ background: habit.color }} />
              <EditableText value={habit.name} onChange={onRename} placeholder="æœªå‘½åç¿’æ…£" />
            </div>
            <button onClick={onRemove}
                    className="p-1 rounded-lg bg-neutral-100 hover:bg-neutral-200"
                    title="åˆªé™¤">
              <IconTrash />
            </button>
          </div>

          <div className="flex items-center gap-3">
            <div className="min-w-[56px] text-xs text-neutral-600">{inRangeCount} æ¬¡</div>
            <div className="flex-1">
              <div className="w-full h-2 bg-neutral-200 rounded-full overflow-hidden">
                <div className="h-full"
                     style={{ width: Math.min(100, (inRangeCount/10)*100) + "%", background: habit.color }} />
              </div>
            </div>
          </div>

          <div className="flex items-center justify-between text-xs text-neutral-600">
            <span>{periodStart} ï½ {periodEnd}</span>
            <button onClick={onToggleToday}
                    className={`px-3 py-1 rounded-xl ${doneToday ? "bg-neutral-300 text-black" : "bg-black text-white"}`}>
              +1
            </button>
          </div>
        </div>
      );
    }

    // ===== App =====
    function App() {
      const fallback = {
        habits: [],
        events: [],
        redemptions: [],
        settings: { rewardName: "åƒé “å¥½æ–™", target: 30, periodDays: 30, periodStart: todayKey() }
      };
      const [state, setState] = useState(() => {
        const s = loadState() || fallback;
        // è³‡æ–™é·ç§»ï¼šè£œé½Š colorã€eventsã€redemptions
        let colorIdx=0;
        s.habits = (s.habits || []).map(h => h.color ? h : ({ ...h, color: PALETTE[(colorIdx++ % PALETTE.length)] }));
        if (!s.events) {
          const ev=[];
          s.habits.forEach(h=>{
            (h.dates || []).sort().forEach((d,i)=>{
              ev.push({ id: uid(), habitId: h.id, color: h.color, date: d, ts: new Date(d+"T12:00:00").getTime()+i });
            });
          });
          s.events = ev;
        }
        if (!s.redemptions) s.redemptions = [];
        return s;
      });

      const today = todayKey();
      useEffect(() => saveState(state), [state]);

      const periodEnd = useMemo(() => {
        const d = new Date(state.settings.periodStart);
        d.setDate(d.getDate() + state.settings.periodDays - 1);
        return d.toISOString().slice(0,10);
      }, [state.settings.periodStart, state.settings.periodDays]);

      const inPeriod = (dStr) => dStr >= state.settings.periodStart && dStr <= periodEnd;

      // ç•¶æœŸ eventsã€å„ç¿’æ…£è¨ˆæ•¸ã€ä»Šæ—¥ç‹€æ…‹
      const eventsInPeriod = useMemo(
        () => state.events.filter(e => inPeriod(e.date)).sort((a,b)=>a.ts-b.ts),
        [state.events, state.settings.periodStart, state.settings.periodDays]
      );
      const countsMap = useMemo(() => {
        const m=new Map();
        eventsInPeriod.forEach(e => m.set(e.habitId, (m.get(e.habitId)||0)+1));
        return m;
      }, [eventsInPeriod]);
      const todayMap = useMemo(() => {
        const m=new Map();
        state.events.forEach(e => { if (e.date === today) m.set(e.habitId, (m.get(e.habitId)||0)+1); });
        return m;
      }, [state.events, today]);

      const total = eventsInPeriod.length;
      const achieved = total >= state.settings.target;

      const setTarget  = (n)    => setState(s => ({ ...s, settings: { ...s.settings, target: n } }));
      const setReward  = (name) => setState(s => ({ ...s, settings: { ...s.settings, rewardName: name } }));

      const nextColor  = (used) => PALETTE[(used % PALETTE.length)];
      const addHabit   = (name) => name.trim() && setState(s => ({
        ...s,
        habits: [...s.habits, { id: uid(), name: name.trim(), color: nextColor(s.habits.length) }]
      }));

      // åš´æ ¼ã€Œä¸€å¤©ä¸€æ¬¡ã€ï¼šä»Šæ—¥å·²æœ‰å°±åˆªé™¤ï¼ˆ-1ï¼‰ï¼Œå¦å‰‡æ–°å¢ï¼ˆ+1ï¼‰
      const toggleToday = (id) => setState(s => {
        const habit = s.habits.find(h => h.id === id);
        if (!habit) return s;
        const idx = s.events.findIndex(e => e.habitId === id && e.date === today);
        const events = idx >= 0
          ? s.events.filter((_,i)=> i !== idx)
          : [...s.events, { id: uid(), habitId: id, color: habit.color, date: today, ts: Date.now() }];
        return { ...s, events };
      });

      const removeHabit = (id) => setState(s => ({
        ...s,
        habits: s.habits.filter(h => h.id !== id),
        events: s.events.filter(e => e.habitId !== id) // ç§»é™¤å…¶ç´€éŒ„ï¼Œé¿å…é ‚éƒ¨æ®˜ç•™
      }));
      const renameHabit = (id, name) => setState(s => ({
        ...s,
        habits: s.habits.map(h => h.id === id ? { ...h, name } : h)
      }));

      const resetPeriod = () => setState(s => ({
        ...s,
        settings: { ...s.settings, periodStart: todayKey() }
      }));

      // å…Œæ›ï¼šè¨˜éŒ„ä¸€è¡Œã€é‡è¨­æœ¬æœŸç‚ºä»Šå¤©ã€æ¸…æ‰ä»Šå¤©çš„ eventsï¼ˆæ–°ä¸€æœŸå¾ 0ï¼‰
      const redeem = () => setState(s => ({
        ...s,
        redemptions: [...s.redemptions, { id: uid(), date: today, reward: s.settings.rewardName }],
        settings: { ...s.settings, periodStart: today },
        events: s.events.filter(e => e.date !== today)
      }));

      // é ‚éƒ¨è‰²å¡Šï¼ˆèˆŠ -> æ–°ï¼‰ï¼Œå³ç«¯ç‚ºæœ€æ–°
      const blocks = eventsInPeriod.map(e => e.color);
      const lastRedemption = state.redemptions[state.redemptions.length - 1];

      return (
        <div className="min-h-screen p-4 md:p-8">
          <div className="mx-auto max-w-3xl grid gap-6">
            <header className="flex items-center justify-between">
              <h1 className="text-2xl font-bold">Habit Tracker</h1>
              <span className="text-sm opacity-70">{today}</span>
            </header>

            <div className="space-y-2">
              <SegmentedBar blocks={blocks} target={state.settings.target} />
              <div className="flex items-center justify-between text-sm text-neutral-700 flex-wrap gap-2">
                <div className="flex items-center gap-2">
                  <span className="font-mono">
                    {total} / <EditableNumber value={state.settings.target} onChange={setTarget} min={1} />
                  </span>
                  {achieved && (
                    <>
                      <span className="px-2 py-0.5 rounded-full bg-neutral-900 text-white text-xs">ğŸ å·²é”æˆ</span>
                      <button onClick={redeem}
                              className="px-2 py-1 rounded-md border border-neutral-700 text-neutral-800 bg-white hover:bg-neutral-100">
                        å…Œæ›
                      </button>
                    </>
                  )}
                </div>
                <div className="flex items-center gap-2">
                  <span className="text-xs text-neutral-500">çå‹µï¼š</span>
                  <EditableText value={state.settings.rewardName} onChange={setReward} placeholder="è‡ªè¨‚çå‹µ" />
                  <button onClick={resetPeriod}
                          className="ml-3 p-1 rounded-md border border-neutral-400 bg-white hover:bg-neutral-100 text-neutral-700"
                          title="æ–°é–‹ä¸€æœŸ">
                    <IconRotateCcw />
                  </button>
                </div>
              </div>
              {lastRedemption && (
                <div className="text-xs text-neutral-500">
                  å·²å…Œæ›ï¼š{lastRedemption.reward}ï¼ˆ{lastRedemption.date}ï¼‰
                </div>
              )}
            </div>

            <section className="space-y-4">
              <NewHabit onAdd={(name)=>addHabit(name)} />
              <div className="grid sm:grid-cols-2 gap-4">
                {state.habits.map(h=>{
                  const inRangeCount  = ( (new Map([... (function(){
                    const m=new Map();
                    eventsInPeriod.forEach(e=>m.set(e.habitId,(m.get(e.habitId)||0)+1));
                    return m;
                  })() ])).get(h.id) ) || 0;
                  const todayDoneCount = ( (new Map([... (function(){
                    const m=new Map();
                    state.events.forEach(e=>{ if(e.date===today) m.set(e.habitId,(m.get(e.habitId)||0)+1); });
                    return m;
                  })() ])).get(h.id) ) || 0;

                  return (
                    <HabitCard key={h.id}
                      habit={{...h, countInRange: inRangeCount}}
                      periodStart={state.settings.periodStart}
                      periodEnd={periodEnd}
                      todayDoneCount={todayDoneCount}
                      onToggleToday={()=>toggleToday(h.id)}
                      onRemove={()=>removeHabit(h.id)}
                      onRename={(name)=>renameHabit(h.id, name)}
                    />
                  );
                })}
              </div>
            </section>

            <footer className="text-center text-xs text-neutral-500 py-6">
              é›¢ç·šå¯ç”¨ Â· æœ¬åœ°å„²å­˜ Â· åŠ åˆ°ä¸»ç•«é¢å³å¯åƒ App
            </footer>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
