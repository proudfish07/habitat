<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="manifest" href="./manifest.json" />
  <meta name="theme-color" content="#111111" />
  <title>Habit Hourglass</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- React & Babel（使用 UMD，全域變數 React / ReactDOM） -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body class="bg-neutral-50">
  <div id="root"></div>

  <!-- 註冊 service worker（可選） -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => navigator.serviceWorker.register('./service-worker.js'));
    }
  </script>

  <script type="text/babel">
    const { useState, useEffect, useMemo } = React;

    // ====== 小圖示（替代 lucide-react）======
    const IconPlus = ({ size=16 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none">
        <path d="M12 5v14M5 12h14" stroke="currentColor" strokeWidth="2" strokeLinecap="round"/>
      </svg>
    );
    const IconTrash = ({ size=16 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none">
        <path d="M3 6h18M8 6V4h8v2M6 6l1 14h10l1-14" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
      </svg>
    );
    const IconRotateCcw = ({ size=16 }) => (
      <svg width={size} height={size} viewBox="0 0 24 24" fill="none">
        <path d="M1 4v6h6M3.51 15a9 9 0 1 0 2.13-9.36L7 10" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"/>
      </svg>
    );

    // ========== Utils & Storage ==========
    function localDateKey(d = new Date()) {
      const yr = d.getFullYear();
      const mo = String(d.getMonth() + 1).padStart(2, "0");
      const da = String(d.getDate()).padStart(2, "0");
      return `${yr}-${mo}-${da}`;
    }
    const todayKey = () => localDateKey();
    const uid = () => Math.random().toString(36).slice(2, 9);

    const LS_KEY = "habit_rewards_v1";
    const loadState = () => {
      try { const raw = localStorage.getItem(LS_KEY); return raw ? JSON.parse(raw) : null; } catch { return null; }
    };
    const saveState = (state) => localStorage.setItem(LS_KEY, JSON.stringify(state));

    const PALETTE = ["#6b7280","#9aa5b1","#8fa3a3","#a3a0b5","#b0a68a","#b28d8d","#8ea0b0","#9aa79a"];
    const PENALTY_COLOR = "#b28d8d"; // 灰玫瑰（扣分顏色）

    // ========== Sanitizers ==========
    function sanitizeText(v, fallback = "") {
      if (v === null || v === undefined) return fallback;
      if (typeof v === "string") return v;
      try { return String(v); } catch { return fallback; }
    }
    function sanitizeNumber(v, fallback = 0) {
      const n = Number(v);
      return Number.isFinite(n) ? n : fallback;
    }
    function sanitizePenalty(p) {
      const name = sanitizeText(p?.name, "");
      const value = Math.max(1, sanitizeNumber(p?.value, 1));
      return { ...(p||{}), name, value };
    }

    // ========== Inline Editable ==========
    function EditableText({ value, onChange, placeholder = "" }) {
      const safeValue = sanitizeText(value, "");
      const [editing, setEditing] = useState(false);
      const [val, setVal] = useState(safeValue);
      useEffect(() => setVal(safeValue), [safeValue]);
      return editing ? (
        <input
          autoFocus
          className="border-b border-neutral-400 bg-transparent focus:outline-none text-sm"
          value={val}
          placeholder={placeholder}
          onChange={(e)=>setVal(e.target.value)}
          onBlur={()=>{ setEditing(false); onChange?.(val.trim() || safeValue); }}
          onKeyDown={(e)=> e.key==="Enter" && (setEditing(false), onChange?.(val.trim() || safeValue)) }
        />
      ) : (
        <button className="border-b border-neutral-300 hover:border-neutral-900 text-sm" onClick={()=>setEditing(true)}>
          {safeValue || placeholder}
        </button>
      );
    }

    function EditableNumber({ value, onChange, min=1 }) {
      const safeNum = sanitizeNumber(value, min);
      const [editing,setEditing]=useState(false);
      const [val,setVal]=useState(String(safeNum));
      useEffect(()=>setVal(String(safeNum)),[safeNum]);
      const commit=()=>{ const n=Math.max(min, sanitizeNumber(val, min)); setEditing(false); onChange?.(n); };
      return editing ? (
        <input autoFocus inputMode="numeric" pattern="[0-9]*"
          className="w-16 border-b border-neutral-400 text-right bg-transparent focus:outline-none"
          value={val} onChange={(e)=>setVal(e.target.value.replace(/[^0-9]/g, ""))}
          onBlur={commit} onKeyDown={(e)=>e.key==="Enter"&&commit()} />
      ) : (
        <button className="border-b border-neutral-300 hover:border-neutral-900 font-mono" onClick={()=>setEditing(true)}>
          {safeNum}
        </button>
      );
    }

    // ========== Segmented Bar（等寬單位塊，右端最新） ==========
    function SegmentedBar({ blocks, target }) {
      const unitPct = 100 / Math.max(1, target);
      const slice = (blocks || []).slice(-target);
      return (
        <div className="w-full h-3 bg-neutral-200 rounded-full overflow-hidden relative">
          {slice.map((color, i) => (
            <div key={i} className="absolute inset-y-0" style={{ left: i * unitPct + "%", width: unitPct + "%", background: color }} />
          ))}
        </div>
      );
    }

    // ========== Small Components ==========
    function NewHabitRow({ onAdd }) {
      const [name,setName]=useState("");
      const [type,setType]=useState("count");
      return (
        <div className="flex gap-2 items-center">
          <input value={name} onChange={e=>setName(e.target.value)} placeholder="新增小習慣"
                className="flex-1 rounded-xl border p-2" />
          <select value={type} onChange={e=>setType(e.target.value)} className="rounded-xl border p-2 text-sm">
            <option value="count">計次</option>
            <option value="streak">累計</option>
          </select>
          <button className="px-3 py-2 rounded-xl bg-black text-white" onClick={()=>{ if(name.trim()){ onAdd?.(name.trim(), type); setName(""); } }}>
            <IconPlus/> 
          </button>
        </div>
      );
    }

    function HabitRow({ habit, inRangeCount, todayDone, onToggle, onRename, onRemove }) {
      const name = sanitizeText(habit?.name, "");
      const count = sanitizeNumber(inRangeCount, 0);
      return (
        <div className="flex items-center justify-between gap-2 py-2">
          <div className="flex items-center gap-2">
            <span className="inline-block w-2.5 h-2.5 rounded-full" style={{ background: habit?.color || "#9aa5b1" }} />
            <EditableText value={name} onChange={(newName)=>onRename({ ...habit, name: newName })} />
            <span className="text-xs text-neutral-500">{habit?.type === 'count' ? '計次' : `累計≤${sanitizeNumber(habit?.streakMax,30)}`}</span>
          
            <span className="text-xs text-neutral-500 ml-2">每次 +</span>
            <EditableNumber
              value={sanitizeNumber(habit?.value, 1)}
              onChange={(v)=> onRename({ ...habit, value: v })}
              min={1}
            />
            <span className="text-xs text-neutral-500">點</span>
          </div>
          <div className="flex items-center gap-2">
            <span className="text-xs text-neutral-600 min-w-[48px] text-right">{count} 次</span>
            <button onClick={onToggle} className={`px-3 py-1 rounded-xl ${todayDone?"bg-neutral-300 text-black":"bg-black text-white"}`}>+1</button>
            <button onClick={onRemove} title="刪除習慣" className="p-1 text-neutral-400 hover:text-black"><IconTrash/></button>
          </div>
        </div>
      );
    }

    function PenaltyRow({ penalty, onChange, onRemove, onFire }) {
      const p = sanitizePenalty(penalty);
      return (
        <div className="flex items-center justify-between gap-2 py-2">
          <div className="flex items-center gap-2">
            <span className="inline-block w-2.5 h-2.5 rounded-full" style={{ background: PENALTY_COLOR }} />
            <EditableText value={p.name} onChange={(name)=>onChange?.({ ...p, name })} placeholder="懲罰名稱" />
            <span className="text-xs text-neutral-500">-{Math.abs(p.value)}</span>
          </div>
          <div className="flex items-center gap-2">
            <button onClick={()=>onFire?.(p)} className="px-3 py-1 rounded-xl bg-neutral-200 text-black text-xs">扣一次</button>
            <button onClick={()=>onRemove?.(p.id)} title="刪除懲罰" className="p-1 text-neutral-400 hover:text-black"><IconTrash/></button>
          </div>
        </div>
      );
    }

    function NewPenaltyRow({ onAdd }) {
      const [name, setName] = useState("");
      const [value, setValue] = useState("1");
      const add = () => {
        const nm = name.trim();
        const v = Math.max(1, sanitizeNumber(value, 1));
        if (!nm) return;
        onAdd?.({ id: uid(), name: nm, value: v });
        setName(""); setValue("1");
      };
      return (
        <div className="flex gap-2 items-center">
          <input value={name} onChange={e=>setName(e.target.value)} placeholder="新增懲罰（例如：炸物）"
                className="flex-1 rounded-xl border p-2" />
          <div className="flex items-center gap-1">
            <span className="text-xs text-neutral-500">-</span>
            <input value={value} onChange={e=>setValue(e.target.value.replace(/[^0-9]/g, ""))}
                  inputMode="numeric" pattern="[0-9]*" className="w-16 rounded-xl border p-2 text-right text-sm" />
            <span className="text-xs text-neutral-500">點</span>
          </div>
          <button onClick={add} className="px-3 py-2 rounded-xl bg-black text-white"><IconPlus/></button>
        </div>
      );
    }

    // ========== Reward Card ==========
    function RewardCard({ reward, onChange, onRemove }) {
      const today = todayKey();
      const startDate = reward.startDate;
      const endDate = useMemo(() => {
        const days = Number.isFinite(reward.periodDays) ? reward.periodDays : 30;
        const d = new Date(startDate);
        d.setDate(d.getDate() + days - 1);
        return localDateKey(d);
      }, [startDate, reward.periodDays]);

      const inPeriod = (d) => d >= startDate && d <= endDate;

      const eventsInPeriod = useMemo(()=> (reward.events||[]).filter(e=>inPeriod(e.date)).sort((a,b)=>a.ts-b.ts), [reward.events, startDate, endDate]);
      const total = eventsInPeriod.reduce((s,e)=> s + sanitizeNumber(e.delta, 0), 0);
      const blocks = eventsInPeriod.map(e=> e.color || "#9aa5b1");
      const achieved = total >= reward.target;

      const countsMap = useMemo(()=>{
        const m=new Map();
        eventsInPeriod.forEach(e=>{ if(e.habitId){ m.set(e.habitId,(m.get(e.habitId)||0)+1); } });
        return m;
      },[eventsInPeriod]);
      const todayMap = useMemo(()=>{
        const m=new Map();
        (reward.events||[]).forEach(e=>{ if(e.date===today && e.habitId){ m.set(e.habitId,(m.get(e.habitId)||0)+1); } });
        return m;
      },[reward.events, today]);

      const setReward = (patch) => onChange({ ...reward, ...patch });

      // ---- Habits ----
      const nextColor = (used) => PALETTE[(used % PALETTE.length)];
      const addHabit = (name, type) => {
        const newHabit = {
          id: uid(),
          name,
          type,
          color: nextColor((reward.habits||[]).length),
          streakMax: 30,
          value: 1,              // << 新增：預設每次 +1，可自行改
        };
        setReward({ habits: [...(reward.habits||[]), newHabit] });
      };
      const renameHabit = (id, next) => setReward({
        habits: (reward.habits||[]).map(h => {
          if (h.id !== id) return h;
          if (typeof next === 'string') return { ...h, name: next };
          return { ...h, ...next }; // 例如 { value: 2 }
        })
      });

      const removeHabit = (id) => setReward({ habits: (reward.habits||[]).filter(h=>h.id!==id), events: (reward.events||[]).filter(e=>e.habitId!==id) });

      function computeStreakDelta(habitId) { // 曆日模式：往回數連續天數
        let streak = 0;
        const evs = reward.events || [];
        const hasEventOn = (key) => evs.some(e => e.habitId === habitId && e.date === key);
      
        // 從昨天開始一路往回，直到遇到沒有打卡的那天
        let d = new Date(today);
        d.setDate(d.getDate() - 1);
        while (true) {
          const key = localDateKey(d);
          if (!hasEventOn(key)) break;
          streak += 1;
          d.setDate(d.getDate() - 1);
        }
      
        const next = streak + 1; // 今天的加分 = 連續天數 + 1
        const streakMax = (reward.habits || []).find(h => h.id === habitId)?.streakMax || 30;
        return Math.min(next, streakMax);
      }

      const toggleHabitToday = (habit) => {
        const idx = (reward.events||[]).findIndex(e => e.habitId===habit.id && e.date===today);
        if (idx >= 0) {
          const events = (reward.events||[]).filter((_,i)=>i!==idx);
          setReward({ events });
        } else {
          const inc = Math.max(1, sanitizeNumber(habit.value, 1));
          const delta = habit.type === 'count'
            ? inc
            : computeStreakDelta(habit.id) * inc;
          
          const ev = { id: uid(), rewardId: reward.id, habitId: habit.id, date: today, ts: Date.now(), delta, color: habit.color };

          setReward({ events: [ ...(reward.events||[]), ev ] });
        }
      };

      // ---- Penalties ----
      const addPenaltyEvent = (p) => {
        const sp = sanitizePenalty(p);
        const ev = { id: uid(), rewardId: reward.id, habitId: null, date: today, ts: Date.now(),delta: -Math.abs(sp.value), color: PENALTY_COLOR, isPenalty: true };
        const evs = reward.events || [];
        setReward({ events: [ ...evs, ev ] });
      };
      const undoLastPenaltyToday = () => {
        const evs = reward.events||[];
        for (let i = evs.length - 1; i >= 0; i--) {
          const e = evs[i];
          if (e.isPenalty && e.date === today) {
            const events = evs.slice(); events.splice(i,1); setReward({ events }); break;
          }
        }
      };
      const addPenalty = (p) => setReward({ penalties: [ ...(reward.penalties||[]), sanitizePenalty(p) ] });
      const updatePenalty = (id, patch) => setReward({ penalties: (reward.penalties||[]).map(p => p.id===id ? sanitizePenalty({ ...p, ...patch }) : p) });
      const removePenalty = (id) => setReward({ penalties: (reward.penalties||[]).filter(p => p.id!==id) });

      // ---- Redeem / New period（清事件 + startDate=今天） ----
      const redeem = () => {
        const redemptions = [ ...((reward.redemptions)||[]), { id: uid(), date: today, note: reward.name } ];
        setReward({ redemptions, startDate: today, events: [] });
      };

      return (
        <div className="rounded-2xl bg-white shadow p-5 grid gap-4">
          <div className="flex items-center justify-between gap-3">
            <div className="flex items-center gap-3">
              <div className="w-3 h-3 rounded-full" style={{ background: reward.color || "#6b7280" }} />
              <EditableText value={reward.name} onChange={(name)=>setReward({ name })} placeholder="獎勵名稱" />
            </div>
            <button onClick={()=>onRemove?.(reward.id)} className="p-1 text-neutral-400 hover:text-red-600" title="刪除此獎勵"><IconTrash/></button>
          </div>

          {/* 期間 & 進度 */}
          <div className="flex items-center gap-2">
            <input
              type="date"
              value={startDate}
              onChange={(e)=> setReward({ startDate: e.target.value })}
              className="border rounded-md px-2 py-1 text-sm"
            />
            <span className="text-neutral-500">～ {endDate}</span>
          </div>
          <SegmentedBar blocks={blocks} target={reward.target} />
          <div className="flex items-center justify-between text-sm text-neutral-700 flex-wrap gap-2">
            <div className="flex items-center gap-3">
              <span className="font-mono">
                {total} / <EditableNumber value={reward.target} onChange={(target)=>setReward({ target })} min={1} />
              </span>
              <span className="text-xs text-neutral-500">期間（天）</span>
              <EditableNumber value={reward.periodDays} onChange={(periodDays)=>setReward({ periodDays })} min={1} />
            </div>
            <div className="flex items-center gap-2">
              <span className="text-xs text-neutral-500">新開一期</span>
              <button onClick={()=>setReward({ startDate: today, events: [] })} className="p-1 rounded-md border border-neutral-400 bg-white hover:bg-neutral-100 text-neutral-700" title="新開一期"><IconRotateCcw/></button>
            </div>
          </div>

          {/* 小習慣清單 */}
          <div className="border-t pt-2">
            {(reward.habits||[]).map(h => (
              <HabitRow key={h.id}
                habit={h}
                inRangeCount={countsMap.get(h.id)||0}
                todayDone={!!todayMap.get(h.id)}
                onToggle={()=>toggleHabitToday(h)}
                onRename={(next)=>renameHabit(h.id, next)}
                onRemove={()=>removeHabit(h.id)}
              />
            ))}
            <NewHabitRow onAdd={addHabit} />
          </div>

          {/* 懲罰列（撤銷置頂 + 與 HabitRow 同風格） */}
          <div className="border-t pt-3 space-y-2">
            <button onClick={undoLastPenaltyToday} className="text-xs px-2 py-1 rounded-md border border-neutral-400 bg-white hover:bg-neutral-100">撤銷上一筆懲罰</button>
            <div className="space-y-1">
              {(reward.penalties||[]).map(p => (
                <PenaltyRow key={p.id}
                  penalty={p}
                  onChange={(np)=>updatePenalty(p.id, np)}
                  onRemove={(id)=>removePenalty(id)}
                  onFire={(pp)=>addPenaltyEvent(pp)}
                />
              ))}
            </div>
            <NewPenaltyRow onAdd={(p)=>addPenalty(p)} />
          </div>

          {reward.redemptions?.length>0 && (
            <div className="text-xs text-neutral-500">已兌換：{reward.redemptions[reward.redemptions.length-1].note}（{reward.redemptions[reward.redemptions.length-1].date}）</div>
          )}
        </div>
      );
    }

    // ========== App ==========
    function fallbackReward() {
      return {
        id: uid(),
        name: "本期獎勵",
        color: "#6b7280",
        target: 30,
        startDate: todayKey(),
        periodDays: 30,
        habits: [],
        penalties: [ { id: uid(), name: "油炸物", value: 5 }, { id: uid(), name: "含糖飲料", value: 2 } ],
        events: [],
        redemptions: [],
      };
    }

    function App(){
      const [state,setState]=useState(()=>{
        const old = loadState();
        if (old && Array.isArray(old.rewards)) return old; // 兼容新結構
        return { rewards: [fallbackReward()] };
      });
      useEffect(()=>saveState(state),[state]);

      const addReward = () => setState(s=>({ rewards: [...s.rewards, fallbackReward()] }));
      const removeReward = (id) => setState(s=>({ rewards: s.rewards.filter(r=>r.id!==id) }));
      const updateReward = (id, patch) => setState(s=>({ rewards: s.rewards.map(r=> r.id===id ? { ...r, ...patch } : r) }));

      // —— Smoke tests ——
      useEffect(()=>{
        try {
          const bad = { id: "t1", name: undefined, value: undefined };
          const good = sanitizePenalty(bad);
          console.assert(typeof good.name === "string", "Penalty name should be string");
          console.assert(Number.isFinite(good.value) && good.value >= 1, "Penalty value should be >=1 number");
        } catch(e) { console.warn("Smoke tests failed", e); }
      }, []);

      return (
        <div className="min-h-screen bg-neutral-50 p-4 md:p-8 text-neutral-900">
          <div className="mx-auto max-w-3xl grid gap-4">
            <header className="flex items-center justify-between">
              <h1 className="text-2xl font-bold">Rewards Tracker</h1>
              <span className="text-sm opacity-70">{todayKey()}</span>
            </header>

            {state.rewards.map(r=> (
              <RewardCard key={r.id}
                reward={r}
                onChange={(patch)=>updateReward(r.id, patch)}
                onRemove={(id)=>removeReward(id)}
              />
            ))}

            <button onClick={addReward} className="flex items-center gap-2 px-3 py-2 border rounded-xl w-max">
              <IconPlus/> 新增獎勵
            </button>
          </div>
        </div>
      );
    }

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>
